#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
//#include <dbus/dbus-glib.h>
#include <dbus/dbus.h>
#include <unistd.h>


void print_iter(DBusMessageIter *piter)
{
   do
   {
     int type = dbus_message_iter_get_arg_type (piter);
     switch (type) {
      case DBUS_TYPE_BOOLEAN:
        {   
          dbus_bool_t val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("boolean %s\n", val ? "true" : "false");
        }   
        break;
      case DBUS_TYPE_BYTE:
        {   
          unsigned char val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("byte %d\n", val);
        }   
        break;
      case DBUS_TYPE_DOUBLE:
          {   
            double val;
            dbus_message_iter_get_basic (piter, &val);
            printf ("double %g\n", val);
            break;
          }   
      case DBUS_TYPE_STRING:
        {   
          char *val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("[%s]\n", val);
        }   
        break;
    case DBUS_TYPE_SIGNATURE:
        {
          char *val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("[%s]\n", val);
        }
        break;
      case DBUS_TYPE_INT16:
        {
          dbus_int16_t val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("int16 %d\n", val);
        }
        break;
      case DBUS_TYPE_UINT16:
        {
          dbus_uint16_t val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("int16 %d\n", val);
        }
        break;
      case DBUS_TYPE_INT32:
        {
          dbus_int32_t val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("int32 %d\n", val);
        }
        break;
    case DBUS_TYPE_UINT32:
        {
          dbus_uint32_t val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("uint32 %u\n", val);
        }
        break;
      case DBUS_TYPE_INT64:
        {
          dbus_int64_t val; val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("int64 %ld\n", val);
        }
        break;
      case DBUS_TYPE_UINT64:
        {
          dbus_uint64_t val; val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("uint64 %lu\n", val);
        }
        break;
      case DBUS_TYPE_OBJECT_PATH:
        {
          char *val;
          dbus_message_iter_get_basic (piter, &val);
          printf ("[%s]\n", val);
        }
        break;
      case DBUS_TYPE_DICT_ENTRY:
      {
        printf("It is %s \n", "DBUS_TYPE_DICT_ENTRY");
        break;
      }
      default:
      break;
      }
   } while (dbus_message_iter_next (piter));
}

int main(void){
  DBusError err;
  DBusConnection *conn;
  DBusMessage *msg, *reply;
  const char *name;
  dbus_error_init (&err);
  conn = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
//
  msg = dbus_message_new_method_call( 
    "org.bluez",          //Service
    "/org/bluez/939/hci0",    //Object path
    "org.bluez.Adapter",  //Interface
    "GetProperties");           // Methods
  if (NULL == msg) {
        fprintf(stderr, "Message Null\n");
        exit(1);
  }
  DBusMessageIter iter;
  DBusPendingCall* pending;
  //dbus_message_iter_init_append(msg, &args);
  if (!dbus_connection_send_with_reply (conn, msg, &pending, -1)) {
        fprintf(stderr, "Out Of Memory!\n");
        exit(1);
  }
  if (NULL == pending) {
      fprintf(stderr, "Pending Call Null\n");
      exit(1); 
  }      
  dbus_connection_flush(conn);
  printf("wait reply\n");
  dbus_pending_call_block(pending);
  printf("reply now\n");
  msg = dbus_pending_call_steal_reply(pending);
  if (NULL == msg) {
      fprintf(stderr, "Reply Null\n");
      exit(1); 
  }      
  // free the pending message handle
  dbus_pending_call_unref(pending);
  char* reply_data;
  if (!dbus_message_iter_init(msg, &iter))
      fprintf(stderr, "Message has no arguments!\n");
  else {
    switch (dbus_message_iter_get_arg_type(&iter)) {
      case DBUS_TYPE_BOOLEAN:
        {
          printf("It is %s \n", "DBUS_TYPE_BOOLEAN");
          dbus_bool_t val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("boolean %s\n", val ? "true" : "false");
	} 
        break;
      case DBUS_TYPE_BYTE:
        {
          printf("It is %s \n", "DBUS_TYPE_BYTE");
          unsigned char val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("byte %d\n", val);
	} 
        break;
      case DBUS_TYPE_DOUBLE:
	  {
            printf("It is %s \n", "DBUS_TYPE_DOUBLE");
	    double val;
	    dbus_message_iter_get_basic (&iter, &val);
	    printf ("double %g\n", val);
	    break;
	  }
      case DBUS_TYPE_STRING:
        {
          printf("It is %s \n", "DBUS_TYPE_STRING");
          char *val;
	  dbus_message_iter_get_basic (&iter, &val);
          printf ("[%s]\n", val);
        }
        break;
      case DBUS_TYPE_SIGNATURE:
        {
          printf("It is %s \n", "DBUS_TYPE_SIGNATURE");
          char *val;
	  dbus_message_iter_get_basic (&iter, &val);
          printf ("[%s]\n", val);
        }
        break;
      case DBUS_TYPE_INT16:
        {
          printf("It is %s \n", "DBUS_TYPE_INT16");
          dbus_int16_t val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("int16 %d\n", val);
        }
        break;
      case DBUS_TYPE_UINT16:
        {
          printf("It is %s \n", "DBUS_TYPE_UINT16");
          dbus_uint16_t val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("int16 %d\n", val);
        }
        break;
      case DBUS_TYPE_INT32:
        {
          printf("It is %s \n", "DBUS_TYPE_INT32");
          dbus_int32_t val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("int32 %d\n", val);
        }
        break;
      case DBUS_TYPE_UINT32:
        {
          printf("It is %s \n", "DBUS_TYPE_UINT32");
          dbus_uint32_t val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("uint32 %u\n", val);
        }
        break;
      case DBUS_TYPE_INT64:
        {
          printf("It is %s \n", "DBUS_TYPE_INT64");
          dbus_int64_t val; val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("int64 %ld\n", val);
        }
        break;
      case DBUS_TYPE_UINT64:
        {
          printf("It is %s \n", "DBUS_TYPE_INT64");
          dbus_uint64_t val; val;
	  dbus_message_iter_get_basic (&iter, &val);
	  printf ("uint64 %lu\n", val);
        }
        break;
      case DBUS_TYPE_OBJECT_PATH:
        {
          printf("It is %s \n", "DBUS_TYPE_OBJECT_PATH");
          char *val;
          dbus_message_iter_get_basic (&iter, &val);
          printf ("[%s]\n", val);
        }
        break;
      case DBUS_TYPE_VARIANT:
        {
          printf("It is %s \n", "DBUS_TYPE_VARIANT");
          DBusMessageIter subiter;
	  dbus_message_iter_recurse (&iter, &subiter);
	  printf ("variant ");
          int subtype = dbus_message_iter_get_arg_type(&subiter);
          //
          printf("type is %d\n", subtype);
         } 
        break;
      case DBUS_TYPE_ARRAY:
        {
          printf("It is %s \n", "DBUS_TYPE_ARRAY");
          DBusMessageIter subiter;
	  dbus_message_iter_recurse (&iter, &subiter);
	  int current_type;
          current_type = dbus_message_iter_get_arg_type (&subiter);
          if (current_type == DBUS_TYPE_BYTE)
	  {
            printf("it is DBUS_TYPE_BYTE\n");
		//print_ay (&subiter, depth);
            break;
	  }
          printf("array [\n");
	  while (current_type != DBUS_TYPE_INVALID)
          {
            print_iter (&subiter);
            dbus_message_iter_next (&subiter);
            current_type = dbus_message_iter_get_arg_type (&subiter);
            if (current_type != DBUS_TYPE_INVALID)
		  printf (",");
          }
          printf("]\n");
        }
        break;
      case DBUS_TYPE_DICT_ENTRY:
        printf("It is %s \n", "DBUS_TYPE_DICT_ENTRY");
        break;
      default:
        printf("It is %d \n", dbus_message_iter_get_arg_type(&iter));
        break;

    }
  }

/*
  else if (DBUS_TYPE_DICT_ENTRY != dbus_message_iter_get_arg_type(&args))
      fprintf(stderr, "Argument is not dict!\n"); 
  else
      dbus_message_iter_get_basic(&args, &reply_data);
  printf("Name [%s]\n", reply_data);
*/
/*
  reply = dbus_connection_send_with_reply_and_block(conn, msg, -1, NULL);
  dbus_message_get_args(reply, NULL, DBUS_TYPE_STRING, &name, DBUS_TYPE_INVALID);
  printf("HCI0 name: [%s]\n", name);
  dbus_message_unref(msg);
  dbus_message_unref(reply);
  dbus_connection_close(conn);
*/
  dbus_message_unref(msg);
  //dbus_connection_close(conn);
  return 0;
}
